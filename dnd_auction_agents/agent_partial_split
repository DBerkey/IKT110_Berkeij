import random
import os
from typing import Any, Dict
from dnd_auction_game import AuctionGameClient

# Global variables to track agent state across rounds
previous_gold = 0
accumulated_interest = 0


def interest_split_strategy(agent_id: str, current_round: int, states: dict[str, dict[str, Any]], 
                            auctions: dict[str, Dict[str, Any]], prev_auctions: dict[str, Dict[str, Any]], bank_state: dict[str, Any]) -> Dict[str, int]:
    """
    Strategy: Wait 4 rounds to accumulate interest, then split previous round's interest 
    among all available auctions.
    """
    global previous_gold, accumulated_interest
    
    agent_state = states[agent_id]
    current_gold = agent_state["gold"]
    
    # Calculate interest earned this round more accurately
    if current_round > 0:
        gold_difference = current_gold - previous_gold
        
        # Get current round's gold income from bank state
        # The income for current round is the first item in remainder_gold_income from previous round
        current_income = 1000  # Default fallback
        if 'remainder_gold_income' in bank_state and len(bank_state['remainder_gold_income']) > 0:
            # The current income should be in the bank state or we can estimate it
            current_income = 1000  # Use default since it's hard to track exactly
        
        # Interest is the gold difference minus the income we received
        estimated_interest = max(0, gold_difference - current_income)
        accumulated_interest = estimated_interest
    
    print(f"Round {current_round}: Gold={current_gold}, Previous={previous_gold}, Interestâ‰ˆ{accumulated_interest}")
    
    bids: Dict[str, int] = {}
    
    # Wait 4 rounds before starting to bid
    if current_round < 4:
        print(f"Round {current_round}: Waiting phase - accumulating interest (Round {current_round+1}/4)")
        previous_gold = current_gold
        return bids
    
    # After round 4, start bidding using previous round's interest
    if accumulated_interest > 0 and len(auctions) > 0:
        # Split the accumulated interest among all available auctions
        bid_per_auction = max(1, int(accumulated_interest / len(auctions)))
        
        print(f"Round {current_round}: Splitting {accumulated_interest} interest among {len(auctions)} auctions = {bid_per_auction} per auction")
        
        remaining_gold = current_gold
        for auction_id, auction in auctions.items():
            # Make sure we don't bid more than we have
            actual_bid = min(bid_per_auction, remaining_gold)
            if actual_bid > 0:
                bids[auction_id] = actual_bid
                remaining_gold -= actual_bid  # Update available gold for remaining bids
                print(f"  Bidding {actual_bid} on auction {auction_id} (die: {auction['die']}, num: {auction['num']}, bonus: {auction['bonus']})")
    else:
        if current_round >= 4:
            print(f"Round {current_round}: No interest to split ({accumulated_interest}) or no auctions ({len(auctions)})")
    
    # Update for next round
    previous_gold = current_gold
    
    return bids

if __name__ == "__main__":
    
    host = "localhost"
    agent_name = "{}_{}".format(os.path.basename(__file__), random.randint(1, 1000))
    player_id = "id_of_human_player"
    port = 8000

    game: AuctionGameClient = AuctionGameClient(host=host,
                            agent_name=agent_name,
                            player_id=player_id,
                            port=port)
    try:
        game.run(interest_split_strategy)
    except KeyboardInterrupt:
        print("<interrupt - shutting down>")

    print("<game is done>")

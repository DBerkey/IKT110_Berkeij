import random
import os
from typing import Any, Dict, List
from dnd_auction_game import AuctionGameClient
import statistics

# Global tracking variables
bid_tracker = {
    'auction_history': [],  # Track all previous auction results
    'opponent_bids': {},    # Track what each opponent bids
    'win_patterns': {},     # Track winning bid patterns per auction type
    'my_performance': {'wins': 0, 'total_bids': 0, 'profit': 0}
}


def smart_predictive_strategy(agent_id: str, current_round: int, states: dict[str, dict[str, Any]], 
                             auctions: dict[str, Dict[str, Any]], prev_auctions: dict[str, Dict[str, Any]], 
                             bank_state: dict[str, Any]) -> Dict[str, int]:
    """
    Smart Predictive Strategy: Learn from previous rounds to make better bids
    
    Key Features:
    1. Track winning bid amounts for different auction types
    2. Learn opponent bidding patterns 
    3. Predict competitive bids needed to win
    4. Focus budget on most profitable auctions
    """
    global bid_tracker
    
    agent_state = states[agent_id]
    current_gold = agent_state["gold"]
    
    # Learn from what happened last round
    if prev_auctions and current_round > 0:
        analyze_previous_results(prev_auctions, agent_id)
    
    print(f"\nüß† Round {current_round} - Smart Analysis")
    print(f"üí∞ Gold: {current_gold} | Performance: {bid_tracker['my_performance']}")
    
    # Don't bid in round 0 - need to learn first
    if current_round == 0:
        print("üìö Learning mode: Observing first round...")
        return {}
    
    # Analyze each auction and predict optimal bids
    auction_predictions = []
    for auction_id, auction in auctions.items():
        prediction = predict_auction_value(auction, current_round, states)
        auction_predictions.append((auction_id, auction, prediction))
    
    # Sort by predicted profitability (value / cost ratio)
    auction_predictions.sort(key=lambda x: x[2]['profit_ratio'], reverse=True)
    
    # Allocate budget to most promising auctions
    bids = allocate_smart_budget(auction_predictions, current_gold)
    
    # Display strategy
    total_bid = sum(bids.values())
    print(f"üìä Bidding {total_bid} across {len(bids)} auctions (keeping {current_gold - total_bid} reserve)")
    
    return bids


def analyze_previous_results(prev_auctions: dict, my_agent_id: str):
    """Learn from what happened in previous auctions"""
    global bid_tracker
    
    for auction_id, data in prev_auctions.items():
        if 'bids' not in data or not data['bids']:
            continue
        
        # Extract auction characteristics
        auction_type = f"d{data['die']}√ó{data['num']}"
        bonus = data['bonus']
        actual_reward = data.get('reward', 0)
        
        # Get all bids for this auction
        all_bids = [(bid['a_id'], bid['gold']) for bid in data['bids']]
        winning_bid = max(bid['gold'] for bid in data['bids'])
        
        # Store auction result
        auction_record = {
            'type': auction_type,
            'bonus': bonus,
            'reward': actual_reward,
            'winning_bid': winning_bid,
            'total_bidders': len(all_bids),
            'all_bids': all_bids
        }
        bid_tracker['auction_history'].append(auction_record)
        
        # Track winning patterns for this auction type
        full_type = f"{auction_type}+{bonus}"
        if full_type not in bid_tracker['win_patterns']:
            bid_tracker['win_patterns'][full_type] = []
        bid_tracker['win_patterns'][full_type].append(winning_bid)
        
        # Track opponent behavior
        for agent_id, bid_amount in all_bids:
            if agent_id not in bid_tracker['opponent_bids']:
                bid_tracker['opponent_bids'][agent_id] = []
            bid_tracker['opponent_bids'][agent_id].append(bid_amount)
        
        # Check my performance
        my_bids = [bid for bid in all_bids if bid[0] == my_agent_id]
        if my_bids:
            bid_tracker['my_performance']['total_bids'] += 1
            my_bid_amount = my_bids[0][1]
            
            if my_bid_amount == winning_bid:  # I won!
                bid_tracker['my_performance']['wins'] += 1
                bid_tracker['my_performance']['profit'] += (actual_reward - my_bid_amount)
                print(f"üèÜ Won auction {auction_id} for {my_bid_amount}, earned {actual_reward} points!")
            else:
                print(f"üìâ Lost auction {auction_id}, bid {my_bid_amount} vs winning {winning_bid}")


def predict_auction_value(auction: dict, current_round: int, states: dict) -> dict:
    """Predict the value and required bid for an auction"""
    global bid_tracker
    
    # Calculate expected point value
    die_size = auction['die']
    num_dice = auction['num']
    bonus = auction['bonus']
    expected_points = ((die_size + 1) / 2 * num_dice) + bonus
    
    # Look up historical data for similar auctions
    auction_type = f"d{die_size}√ó{num_dice}"
    full_type = f"{auction_type}+{bonus}"
    
    predicted_winning_bid = predict_winning_bid(full_type, auction_type)
    competitor_threat = assess_competitor_threat(states)
    
    # Adjust prediction based on competition
    adjusted_bid = int(predicted_winning_bid * competitor_threat)
    
    # Calculate profit ratio (expected points per gold spent)
    profit_ratio = expected_points / max(1, adjusted_bid)
    
    # Calculate confidence based on how much data we have
    confidence = calculate_prediction_confidence(full_type, auction_type)
    
    return {
        'expected_points': expected_points,
        'predicted_winning_bid': adjusted_bid,
        'profit_ratio': profit_ratio,
        'confidence': confidence,
        'reasoning': f"EV={expected_points:.1f}, HistBid={predicted_winning_bid}, Comp={competitor_threat:.2f}"
    }


def predict_winning_bid(full_type: str, auction_type: str) -> int:
    """Predict how much we need to bid to win this auction"""
    global bid_tracker
    
    # First try exact match (same dice + bonus)
    if full_type in bid_tracker['win_patterns'] and bid_tracker['win_patterns'][full_type]:
        recent_wins = bid_tracker['win_patterns'][full_type][-3:]  # Last 3 similar auctions
        return int(statistics.mean(recent_wins) * 1.1)  # Bid 10% above average
    
    # If no exact match, try same dice type (ignoring bonus)
    similar_auctions = []
    for pattern_type, winning_bids in bid_tracker['win_patterns'].items():
        if pattern_type.startswith(auction_type):
            similar_auctions.extend(winning_bids)
    
    if similar_auctions:
        return int(statistics.mean(similar_auctions[-5:]) * 1.1)  # Use recent similar auctions
    
    # If no similar data, use general historical average
    if bid_tracker['auction_history']:
        all_winning_bids = [auction['winning_bid'] for auction in bid_tracker['auction_history'][-10:]]
        return int(statistics.mean(all_winning_bids))
    
    # Fallback if no data at all
    return 100


def assess_competitor_threat(states: dict) -> float:
    """Assess how competitive the current environment is"""
    global bid_tracker
    
    if not bid_tracker['opponent_bids']:
        return 1.0  # No data, assume normal competition
    
    # Calculate average opponent gold
    opponent_golds = [state['gold'] for aid, state in states.items()]
    avg_opponent_gold = statistics.mean(opponent_golds) if opponent_golds else 1000
    
    # Check if opponents are bidding more aggressively lately
    recent_aggression = 1.0
    for agent_id, bid_history in bid_tracker['opponent_bids'].items():
        if len(bid_history) >= 3:
            recent_bids = bid_history[-3:]
            older_bids = bid_history[:-3] if len(bid_history) > 3 else bid_history
            
            if older_bids:
                recent_avg = statistics.mean(recent_bids)
                older_avg = statistics.mean(older_bids)
                if recent_avg > older_avg * 1.2:  # 20% increase in bidding
                    recent_aggression *= 1.3
    
    # Factor in gold availability
    gold_factor = min(2.0, avg_opponent_gold / 5000)  # More gold = more competitive
    
    return min(2.0, recent_aggression * gold_factor)


def calculate_prediction_confidence(full_type: str, auction_type: str) -> float:
    """Calculate how confident we are in our prediction"""
    global bid_tracker
    
    # Confidence based on amount of data
    exact_matches = len(bid_tracker['win_patterns'].get(full_type, []))
    similar_matches = sum(len(bids) for pattern, bids in bid_tracker['win_patterns'].items() 
                         if pattern.startswith(auction_type))
    
    # High confidence with exact matches, medium with similar, low with none
    if exact_matches >= 3:
        return 0.9
    elif exact_matches >= 1:
        return 0.7
    elif similar_matches >= 3:
        return 0.6
    elif similar_matches >= 1:
        return 0.4
    else:
        return 0.2


def allocate_smart_budget(auction_predictions: List, total_gold: int) -> dict:
    """Allocate budget across auctions based on predicted profitability"""
    
    # Keep 25% of gold as safety reserve
    available_budget = int(total_gold * 0.75)
    bids = {}
    
    print("\nüìã Auction Analysis:")
    for auction_id, auction, prediction in auction_predictions:
        print(f"  {auction_id}: {prediction['reasoning']} (Confidence: {prediction['confidence']:.1f})")
    
    # Only bid on auctions with good profit ratios and reasonable confidence
    viable_auctions = [
        (auction_id, auction, prediction) 
        for auction_id, auction, prediction in auction_predictions
        if prediction['profit_ratio'] > 0.1 and prediction['confidence'] > 0.3
    ]
    
    if not viable_auctions:
        print("‚ö†Ô∏è No viable auctions found - being conservative")
        return {}
    
    # Calculate total "value score" for proportional allocation
    total_value_score = sum(pred['profit_ratio'] * pred['confidence'] for _, _, pred in viable_auctions)
    
    for auction_id, auction, prediction in viable_auctions:
        # Allocate budget proportional to value score
        value_score = prediction['profit_ratio'] * prediction['confidence']
        proportion = value_score / total_value_score
        
        # Calculate bid amount
        base_allocation = int(available_budget * proportion)
        suggested_bid = prediction['predicted_winning_bid']
        
        # Use the higher of proportional allocation or predicted winning bid
        final_bid = max(base_allocation, suggested_bid)
        
        # Don't exceed remaining budget
        final_bid = min(final_bid, available_budget)
        
        if final_bid > 0:
            bids[auction_id] = final_bid
            available_budget -= final_bid
            print(f"üí° {auction_id}: Bidding {final_bid} (profit ratio: {prediction['profit_ratio']:.2f})")
        
        # Stop if we run out of budget
        if available_budget <= 0:
            break
    
    return bids


if __name__ == "__main__":
    
    host = "localhost"
    agent_name = "{}_{}".format(os.path.basename(__file__), random.randint(1, 1000))
    player_id = "id_of_human_player"
    port = 8000

    game: AuctionGameClient = AuctionGameClient(host=host,
                            agent_name=agent_name,
                            player_id=player_id,
                            port=port)
    try:
        game.run(smart_predictive_strategy)
    except KeyboardInterrupt:
        print("<interrupt - shutting down>")

    print("<game is done>")
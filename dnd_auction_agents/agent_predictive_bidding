import random
import os
from typing import Any, Dict, List, Tuple
from dnd_auction_game import AuctionGameClient
import statistics

# Global variables to track historical data
auction_history: List[Dict] = []
bidding_patterns: Dict[str, List[int]] = {}  # agent_id -> list of bid amounts
win_rates: Dict[str, float] = {}  # agent_id -> win rate
average_winning_bids: Dict[str, float] = {}  # auction_type -> average winning bid


def predictive_bidding_strategy(agent_id: str, current_round: int, states: dict[str, dict[str, Any]], 
                               auctions: dict[str, Dict[str, Any]], prev_auctions: dict[str, Dict[str, Any]], 
                               bank_state: dict[str, Any]) -> Dict[str, int]:
    """
    Strategy: Analyze previous auction results to predict optimal bids
    - Learn from winning bid patterns
    - Analyze competitor behavior
    - Predict auction values based on historical outcomes
    - Adjust bids based on opponent strategies
    """
    global auction_history, bidding_patterns, win_rates, average_winning_bids
    
    agent_state = states[agent_id]
    current_gold = agent_state["gold"]
    
    # Update historical data from previous auctions
    if prev_auctions:
        update_historical_data(prev_auctions, states)
    
    print(f"\nRound {current_round}: Gold={current_gold}")
    
    bids = {}
    
    # Don't bid in first round (no data yet)
    if current_round == 0:
        print("Round 0: No historical data yet - skipping bids")
        return bids
    
    # Analyze current auctions and predict optimal bids
    for auction_id, auction in auctions.items():
        predicted_bid = predict_optimal_bid(auction, current_round, current_gold, states)
        
        if predicted_bid > 0 and predicted_bid <= current_gold:
            bids[auction_id] = predicted_bid
            current_gold -= predicted_bid
            
            expected_value = calculate_expected_value(auction)
            print(f"  Bidding {predicted_bid} on {auction_id} (d{auction['die']}×{auction['num']}+{auction['bonus']}) - EV: {expected_value:.1f}")
    
    total_bid = sum(bids.values())
    print(f"Total bids: {total_bid}, Remaining gold: {current_gold}")
    
    return bids


def update_historical_data(prev_auctions: dict, states: dict):
    """Update our knowledge base with results from previous auctions"""
    global auction_history, bidding_patterns, win_rates, average_winning_bids
    
    for auction_id, auction_data in prev_auctions.items():
        if 'bids' in auction_data and auction_data['bids']:
            # Store auction outcome
            auction_record = {
                'auction_id': auction_id,
                'die': auction_data['die'],
                'num': auction_data['num'], 
                'bonus': auction_data['bonus'],
                'reward': auction_data.get('reward', 0),
                'bids': auction_data['bids'],
                'winning_bid': max(bid['gold'] for bid in auction_data['bids']) if auction_data['bids'] else 0
            }
            auction_history.append(auction_record)
            
            # Update bidding patterns for each agent
            for bid_info in auction_data['bids']:
                agent_id = bid_info['a_id']
                bid_amount = bid_info['gold']
                
                if agent_id not in bidding_patterns:
                    bidding_patterns[agent_id] = []
                bidding_patterns[agent_id].append(bid_amount)
            
            # Calculate auction type key for averaging
            auction_type = f"d{auction_data['die']}×{auction_data['num']}"
            if auction_type not in average_winning_bids:
                average_winning_bids[auction_type] = []
            if auction_record['winning_bid'] > 0:
                average_winning_bids[auction_type].append(auction_record['winning_bid'])


def predict_optimal_bid(auction: dict, current_round: int, available_gold: int, states: dict) -> int:
    """Predict the optimal bid for an auction based on historical data"""
    global auction_history, bidding_patterns, average_winning_bids
    
    expected_value = calculate_expected_value(auction)
    auction_type = f"d{auction['die']}×{auction['num']}"
    
    # Strategy 1: Historical winning bid analysis
    historical_bid = get_historical_winning_bid(auction_type)
    
    # Strategy 2: Competitor behavior analysis
    competitor_prediction = predict_competitor_bids(states, available_gold)
    
    # Strategy 3: Expected value based bidding
    ev_based_bid = int(expected_value * get_ev_multiplier(current_round))
    
    # Strategy 4: Adaptive bidding based on success rate
    adaptive_factor = get_adaptive_factor()
    
    # Combine strategies
    base_bid = max(historical_bid, competitor_prediction, ev_based_bid)
    final_bid = int(base_bid * adaptive_factor)
    
    # Safety constraints
    min_bid = max(1, int(expected_value * 0.3))  # Never bid less than 30% of EV
    max_bid = min(available_gold, int(expected_value * 2.0))  # Never bid more than 200% of EV or available gold
    
    final_bid = max(min_bid, min(final_bid, max_bid))
    
    return final_bid


def calculate_expected_value(auction: dict) -> float:
    """Calculate the expected point value of an auction"""
    die_size = auction['die']
    num_dice = auction['num']
    bonus = auction['bonus']
    
    # Expected value of a die is (max + min) / 2 = (die_size + 1) / 2
    expected_per_die = (die_size + 1) / 2
    expected_total = (expected_per_die * num_dice) + bonus
    
    return max(0, expected_total)


def get_historical_winning_bid(auction_type: str) -> int:
    """Get average winning bid for similar auctions"""
    global average_winning_bids
    
    if auction_type in average_winning_bids and average_winning_bids[auction_type]:
        return int(statistics.mean(average_winning_bids[auction_type]))
    
    # If no data for exact type, look for similar dice types
    die_size = int(auction_type.split('×')[0][1:])  # Extract die size from "d6×2"
    
    similar_bids = []
    for key, bids in average_winning_bids.items():
        key_die_size = int(key.split('×')[0][1:])
        if abs(key_die_size - die_size) <= 2:  # Similar die sizes
            similar_bids.extend(bids)
    
    if similar_bids:
        return int(statistics.mean(similar_bids))
    
    return 50  # Default fallback


def predict_competitor_bids(states: dict, my_gold: int) -> int:
    """Predict what competitors might bid based on their patterns"""
    global bidding_patterns
    
    if not bidding_patterns:
        return 100  # Default if no data
    
    # Analyze competitor gold and recent bidding patterns
    competitor_golds = [state['gold'] for aid, state in states.items()]
    max_competitor_gold = max(competitor_golds) if competitor_golds else 1000
    
    # Predict they'll bid a fraction of their gold
    predicted_competitor_bid = int(max_competitor_gold * 0.15)  # Assume 15% of gold
    
    # Add some buffer to outbid them
    return predicted_competitor_bid + 20


def get_ev_multiplier(current_round: int) -> float:
    """Get multiplier for expected value based bidding that adapts over time"""
    global auction_history
    
    # Start conservative, become more aggressive as we learn
    base_multiplier = 0.6
    
    if len(auction_history) > 5:
        # Calculate our success rate
        our_wins = sum(1 for auction in auction_history[-10:] 
                      if any(bid.get('a_id') == 'our_agent' for bid in auction.get('bids', [])))
        success_rate = our_wins / min(10, len(auction_history))
        
        # Adjust based on success
        if success_rate < 0.2:  # Too few wins
            base_multiplier += 0.3
        elif success_rate > 0.6:  # Too many wins (overbidding)
            base_multiplier -= 0.2
    
    # Become more aggressive in later rounds
    round_factor = 1.0 + (current_round * 0.05)
    
    return base_multiplier * round_factor


def get_adaptive_factor() -> float:
    """Get adaptive factor based on overall performance"""
    global auction_history
    
    if len(auction_history) < 3:
        return 1.0
    
    # Analyze recent performance
    recent_auctions = auction_history[-5:]
    total_reward = sum(auction.get('reward', 0) for auction in recent_auctions)
    total_winning_bids = sum(auction.get('winning_bid', 0) for auction in recent_auctions)
    
    if total_winning_bids == 0:
        return 1.2  # Be more aggressive if no wins
    
    roi = total_reward / total_winning_bids if total_winning_bids > 0 else 0
    
    # Adjust bidding based on ROI
    if roi > 1.5:  # Good ROI, can bid more aggressively
        return 1.3
    elif roi < 0.8:  # Poor ROI, be more conservative
        return 0.7
    else:
        return 1.0


if __name__ == "__main__":
    
    host = "localhost"
    agent_name = "{}_{}".format(os.path.basename(__file__), random.randint(1, 1000))
    player_id = "id_of_human_player"
    port = 8000

    game: AuctionGameClient = AuctionGameClient(host=host,
                            agent_name=agent_name,
                            player_id=player_id,
                            port=port)
    try:
        game.run(predictive_bidding_strategy)
    except KeyboardInterrupt:
        print("<interrupt - shutting down>")

    print("<game is done>")